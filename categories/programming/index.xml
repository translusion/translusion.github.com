<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Programming on Trans lusion</title>
    <link>http://localhost:1313/categories/programming/</link>
    <description>Recent content in Programming on Trans lusion</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 21 Dec 2014 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/categories/programming/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Tricks in Julia</title>
      <link>http://localhost:1313/posts/julia-tricks/</link>
      <pubDate>Sun, 21 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/julia-tricks/</guid>
      <description>

&lt;p&gt;After doing various small Julia projects I&amp;rsquo;ve had to learn a number of tricks or solutions to small problems, that I think would be usefull to collect:&lt;/p&gt;

&lt;h3 id=&#34;parsing-strings:59bb671a63313562ed2551763f52b78c&#34;&gt;Parsing Strings&lt;/h3&gt;

&lt;p&gt;Extract 3 numbers from a string into 3 variables:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;a, b, c = map(int, split(&amp;quot;11 12 13&amp;quot;))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;initialization:59bb671a63313562ed2551763f52b78c&#34;&gt;Initialization&lt;/h3&gt;

&lt;p&gt;There are some gotchas with Julia initialization if you come from C/C++ background although this should not be so odd to Python or Ruby developers.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; type Point
    x::Int
    y::Int
  end

&amp;gt; points = fill(Point(0, 0), 4)
4-element Array{Point,1}:
 Point(0,0)
 Point(0,0)
 Point(0,0)
 Point(0,0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That looks all fine, until you make a change and get this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; points[2].x = 20
&amp;gt; points
4-element Array{Point,1}:
 Point(20,0)
 Point(20,0)
 Point(20,0)
 Point(20,0)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That was probably not as expected. The reason for this is that references to the created &lt;code&gt;Point&lt;/code&gt; object in fill is copied not the values themselves. So what we actually got to do is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;points = [Point(0, 0) for _ in 1:4]
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;integers:59bb671a63313562ed2551763f52b78c&#34;&gt;Integers&lt;/h2&gt;

&lt;p&gt;There are a lot of issues with just dealing with something simple as integers. First of all how do yo get the min and max values of the integers you are using:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; typemax(Int8)
127
&amp;gt; typemax(Uint8)
0xff # which is 255 decimal
&amp;gt; typemin(Int8)
-128
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One also has to remember that Julia integers do not get promoted to larger values when overflowing. So e.g. taking the factorial of a really big number like 100 requires using &lt;code&gt;BigInt&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; &amp;gt; factorial(BigInt(25))
 15511210043330985984000000
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;division:59bb671a63313562ed2551763f52b78c&#34;&gt;Division&lt;/h3&gt;

&lt;p&gt;One thing I got confused by being more used to C/C++ is how division works in Julia. There are several ways of doing it depending on what you want. Using integers in division does not produce integers automatically. The default is to give floating point answer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; 10 / 6
1.6666666666666667
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which has of course the minor inaccuracies of floating point arithmetic. If you want accurate results you can compute fractions with the &lt;code&gt;//&lt;/code&gt; division operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; a = 10 // 6
5//3
&amp;gt; a.num
5
&amp;gt; a.div
3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to work with C/C++ style division then we use the &lt;code&gt;div&lt;/code&gt;, &lt;code&gt;rem&lt;/code&gt; and &lt;code&gt;mod&lt;/code&gt; functions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; div(10, 6)
1
&amp;gt; rem(10, 6)
4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;C/C++ style remainder&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; 10 % 6
4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Modulus is not quite the same as remaineder. E.g.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; rem(-21, 4)
-1
&amp;gt; mod(-21, 4)
3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With modulus we can imagine doing calculations on a clock.&lt;/p&gt;

&lt;h3 id=&#34;reading-files:59bb671a63313562ed2551763f52b78c&#34;&gt;Reading files&lt;/h3&gt;

&lt;p&gt;Julia has some nice ways you can compose functions to read files.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;lines = open(readlines, &amp;quot;myfile.txt&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This corresponds to writing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;f = open(&amp;quot;myfile.txt&amp;quot;)
lines = readlines(f)
close(f)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the julia &lt;code&gt;do end&lt;/code&gt; syntax sugar you can use this to conveniently read a file and not forget to close it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open(&amp;quot;myfile.txt&amp;quot;) do f
   println(readline(f))     # print out first line in file
end                         # file stream automatically closes here
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;working-with-dates:59bb671a63313562ed2551763f52b78c&#34;&gt;Working with dates&lt;/h3&gt;

&lt;p&gt;This is just to show how to deal with a common case:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; using Dates
&amp;gt; (date, time) = split(&amp;quot;5/8/2014 0:16:03&amp;quot;)
2-element Array{SubString{ASCIIString},1}:
 &amp;quot;5/8/2014&amp;quot;
 &amp;quot;0:16:03&amp;quot; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then as shown before we can unpack an array into separate variables like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; year, month, day = reverse(map(int, split(date, &#39;/&#39;)))
3-element Array{Int64,1}:
 2014
    8
    5
&amp;gt; date = Date(year, month, day)
2014-08-05
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You could also do this in one go by unpacking an array into function arguments using &lt;code&gt;...&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; Date(reverse(map(int, split(date, &#39;/&#39;)))...)
2014-08-05
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;enumeration:59bb671a63313562ed2551763f52b78c&#34;&gt;Enumeration&lt;/h3&gt;

&lt;p&gt;Regular enumeration in Julia is straightforward but it might not be obvious how you enumerate over both values and keys or indicies in an array or dictionary:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; for (index, value) in enumerate([&amp;quot;one&amp;quot;, &amp;quot;two&amp;quot;, &amp;quot;three&amp;quot;])
           println(index, &amp;quot;: &amp;quot;, value)
       end
1: one
2: two
3: three
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;accessing-fields-of-a-type:59bb671a63313562ed2551763f52b78c&#34;&gt;Accessing fields of a type&lt;/h3&gt;

&lt;p&gt;The syntax for accessing fields known at compile time is similar in Julia as in most other languages with Algol syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type FooBar
    foo::Int64
    bar::String
end

&amp;gt; a = FooBar(42, &amp;quot;The answer to everything&amp;quot;)
&amp;gt; a.bar
&amp;quot;The answer to everything&amp;quot;
&amp;gt; a.foo
42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However accessing fields not known at compile time is different. Imagine the user inputs the name of a field to access or the names of fields are read of a file. Unlike Ruby and Python, Julia&amp;rsquo;s objects are not implemented as hashtables. So accessing fields given a name is a bit different:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; a.(:bar)
&amp;quot;The answer to everything&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you only got the name of a field as a string you can do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; a.(symbol(&amp;quot;bar&amp;quot;))
&amp;quot;The answer to everything&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To find out what fields actually exist you can use &lt;code&gt;names&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; names(FooBar)
2-element Array{Symbol,1}:
 :foo
 :bar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively if you got an instance you can see both the name of the fields and their values with &lt;code&gt;dump&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt; dump(a)
FooBar 
  foo: Int64 42
  bar: ASCIIString &amp;quot;The answer to everything&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Most of these code snippets or approaches I picked up from doing small things like implement an algorithm in &lt;a href=&#34;https://projecteuler.net&#34;&gt;project Euler&lt;/a&gt;. I hope to write some bigger piece of code and see how Julia stacks up and how well suited Julia is for more software engineering type of challenges.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Beautiful Julia: Cool language constructs and Tricks for Beginners</title>
      <link>http://localhost:1313/posts/beautiful-julia/</link>
      <pubDate>Sun, 14 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/beautiful-julia/</guid>
      <description>

&lt;p&gt;I just read &lt;a href=&#34;http://www.hackerearth.com/notes/praveen97uma/beautiful-python-some-cool-language-constructs-and-tricks-for-beginners/&#34;&gt;this blog&lt;/a&gt; about cool language constructs in Python. Before clicking it I thought to myself: are there cool things only Python can do or could I easily replicate this in my favorite script language &lt;a href=&#34;http://julialang.org&#34;&gt;Julia&lt;/a&gt;?&lt;/p&gt;

&lt;p&gt;So without further ado, her are some examples.&lt;/p&gt;

&lt;h3 id=&#34;reverse-an-iterable:cd102e3cfa31e3f431f8e244b481d2f3&#34;&gt;Reverse an iterable&lt;/h3&gt;

&lt;p&gt;There are two ways of doing this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; julia&amp;gt; a = [1, 2, 4]
 3-element Array{Int64,1}:
  1
  2
  4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The most obvious way is the &lt;code&gt;reverse&lt;/code&gt; function&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; julia&amp;gt; reverse(a)
 3-element Array{Int64,1}:
  4
  2
  1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But we can also do something similar to the Python example, exept Julia requires you to be a bit more explicit about the start and end of the slice&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; julia&amp;gt; a[end:-1:1]
 3-element Array{Int64,1}:
  4
  2
  1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This of course works for any types:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;julia&amp;gt; reverse(b)
(4,3,2)

julia&amp;gt; b[end:-1:1]
(4,3,2)

julia&amp;gt; c = &amp;quot;This is a string&amp;quot;
&amp;quot;This is a string&amp;quot;

julia&amp;gt; reverse(c)
&amp;quot;gnirts a si sihT&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Julia follows the Ruby convention of suffixing with &lt;code&gt;!&lt;/code&gt; if the function is mutating, so we can be confident these functions created copies.&lt;/p&gt;

&lt;h3 id=&#34;swapping-the-values-of-two-variables:cd102e3cfa31e3f431f8e244b481d2f3&#34;&gt;Swapping the values of two variables&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;julia&amp;gt; a, b = 1, 2
(1,2)

julia&amp;gt; a, b = b, a
(2,1)

julia&amp;gt; a
2

julia&amp;gt; b
1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the python example, the author Praveen Kumar disassembled the Python code to demonstrate how it worked by showing the bytecode. That will be quite different for &lt;a href=&#34;http://julialang.org&#34;&gt;Julia&lt;/a&gt; as Julia JITs different implementations based on the types of arguments. That is why Julia is so fast. E.g. when we define a function that swaps in Julia we get a generic function which will be specialized when called by the Just in Time compiler:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;julia&amp;gt; foo(a, b) = a, b = b, a
foo (generic function with 1 method)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So when dumping the assembly with &lt;code&gt;code_native&lt;/code&gt; we have to specify what the types of arguments  will be as second argument:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;julia&amp;gt; code_native(foo, (Int, Int))
    .section    __TEXT,__text,regular,pure_instructions
Filename: none
Source line: 1
    push    RBP
    mov RBP, RSP
Source line: 1
    movq    XMM1, RDI
    movq    XMM0, RSI
    punpcklqdq  XMM0, XMM1      ## xmm0 = xmm0[0],xmm1[0]
    pop RBP
    ret
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want the bytecode like Python we get something that I consider less readable as it is LLVM based which contains a lot of type information to be able to generate efficient machien code output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;julia&amp;gt; code_llvm(foo, (Int, Int))

define &amp;lt;2 x i64&amp;gt; @&amp;quot;julia_foo;20220&amp;quot;(i64, i64) {
top:
  %2 = insertelement &amp;lt;2 x i64&amp;gt; undef, i64 %1, i32 0, !dbg !1422, !julia_type !1423
  %3 = insertelement &amp;lt;2 x i64&amp;gt; %2, i64 %0, i32 1, !dbg !1422, !julia_type !1423
  ret &amp;lt;2 x i64&amp;gt; %3, !dbg !1422
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This isn&amp;rsquo;t obviously readable so we need to consult the &lt;a href=&#34;http://llvm.org/releases/2.6/docs/LangRef.html&#34;&gt;LLVM reference&lt;/a&gt; manual. &lt;a href=&#34;http://llvm.org/releases/2.6/docs/LangRef.html#i_insertelement&#34;&gt;insertelement&lt;/a&gt; is instruction which insert an element into a vector at given index.&lt;/p&gt;

&lt;p&gt;First part &lt;code&gt;&amp;lt;2 x i64&amp;gt;&lt;/code&gt; is a type annotation saying we are operating on a 2 element 64 bit integer vector.&lt;/p&gt;

&lt;p&gt;First argument is the vector register to operate on. In the first case that is &lt;code&gt;undef&lt;/code&gt; while in the next line it is &lt;code&gt;%2&lt;/code&gt;, which is where the result of the first line was put.&lt;/p&gt;

&lt;p&gt;Second argument &lt;code&gt;i64 %1&lt;/code&gt; says we are inserting a 64 bit integer element. Where is given in third argument: &lt;code&gt;i32 0&lt;/code&gt;. Insert at index 0 (given as a 32 bit integer).&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll leave it as a readers excercise to figure out exactly how this performs a swap as going into the nitty bitty details of this was not the intention of this blog post.&lt;/p&gt;

&lt;h3 id=&#34;enumerate:cd102e3cfa31e3f431f8e244b481d2f3&#34;&gt;Enumerate&lt;/h3&gt;

&lt;p&gt;Interestingly the &lt;a href=&#34;http://julialang.org&#34;&gt;Julia&lt;/a&gt; approach for iterating over both index and value is almost identical to that of Python:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;julia&amp;gt; for (index, value) in enumerate([&amp;quot;foo&amp;quot;, &amp;quot;bar&amp;quot;, &amp;quot;zoo&amp;quot;])
         println(index, &amp;quot; &amp;quot; , value)
       end
1 foo
2 bar
3 zoo
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;splitting-a-string-into-a-list-of-words-and-joining-them-back:cd102e3cfa31e3f431f8e244b481d2f3&#34;&gt;Splitting a string into a list of words and joining them back&lt;/h3&gt;

&lt;p&gt;Splitting and joining is similar to Python except Julia isn&amp;rsquo;t really object oriented so function name comes first as Julia uses multiple dispatch to decide which implementation to call.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;julia&amp;gt; b = split(&amp;quot;This is a string&amp;quot;)
4-element Array{SubString{ASCIIString},1}:
 &amp;quot;This&amp;quot;  
 &amp;quot;is&amp;quot;    
 &amp;quot;a&amp;quot;     
 &amp;quot;string&amp;quot;

julia&amp;gt; join(b, &amp;quot; &amp;quot;)
&amp;quot;This is a string&amp;quot;

julia&amp;gt; join(b, &amp;quot;, &amp;quot;)
&amp;quot;This, is, a, string&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nesting functions call is sometimes hard to read, so Julia offers the &lt;code&gt;|&amp;gt;&lt;/code&gt; operator to write the code in similar sequence as with object oriented languages .e.g:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;julia&amp;gt; &amp;quot;This is a string&amp;quot; |&amp;gt; split |&amp;gt; join
&amp;quot;Thisisastring&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;list-comprehensions:cd102e3cfa31e3f431f8e244b481d2f3&#34;&gt;List Comprehensions&lt;/h3&gt;

&lt;p&gt;The traditional imperative way transforming on list to a new one is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;julia&amp;gt; M = String[]
0-element Array{String,1}

julia&amp;gt; for word in L
           push!(M, word[1:3])
       end

julia&amp;gt; M
4-element Array{String,1}:
 &amp;quot;Jul&amp;quot;
 &amp;quot;mak&amp;quot;
 &amp;quot;peo&amp;quot;
 &amp;quot;lov&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Quite similar to the Python example except Julia lists havea type so you have to specify that it is a String. You can create a python like array but then you need to specify that it takes any element:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;julia&amp;gt; M = Any[]
0-element Array{Any,1}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With list comperhensions you can do this more elegantly with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;julia&amp;gt; M = [word[1:3] for word in L]
4-element Array{Any,1}:
 &amp;quot;Jul&amp;quot;
 &amp;quot;mak&amp;quot;
 &amp;quot;peo&amp;quot;
 &amp;quot;lov&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However for &lt;a href=&#34;http://julialang.org&#34;&gt;Julia&lt;/a&gt; it would be more idiomatic to express what you are doing. E.g. in this case we are mapping from one array to another which we can express like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;julia&amp;gt; M = map(word -&amp;gt;  word[1:3], L)
4-element Array{ASCIIString,1}:
 &amp;quot;Jul&amp;quot;
 &amp;quot;mak&amp;quot;
 &amp;quot;peo&amp;quot;
 &amp;quot;lov&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we want to filter a list by producing a new list containg only the elements with length greater than 5 we would do it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for word in L
  if length(word) &amp;gt; 5
    push!(M, word)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With Python we could solve this with a list comperhension however with Julia you have to explicity state that you are filtering:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;M = filter(word -&amp;gt; length(word) &amp;gt; 5, L)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reason for this is that Julia has bultin support for multidimensional arrays, given that it was designed for scientific computing where this is important. There is no natural way to filter a multi dimensional array, as e.g. every row in a matrix needs to have the same number of columns.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Dynamic Typing as a Paradigm</title>
      <link>http://localhost:1313/posts/dynamic_typing_as_a_paradigm/</link>
      <pubDate>Mon, 08 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/dynamic_typing_as_a_paradigm/</guid>
      <description>

&lt;p&gt;The Dynamic vs Static Typing debate has been going on for decades and never seems to end. While I like both static and dynamic programming languages I probably have a slight preference for dynamic typing. However I feel of the two types of languages I feel the dynamic ones are the ones that are most profoundly misunderstood. The popular blog post [Dynamic languages are static languages][dynisstatic] illustrates the misunderstanding very well.&lt;/p&gt;

&lt;p&gt;I think part of the problem is that when trying to articulate what the advantages of dynamic languages are it is easy to get very vague. So I am trying another approach.&lt;/p&gt;

&lt;h2 id=&#34;dynamic-typing-as-a-paradigm:971ba13e9010bce2001cf2f689aed692&#34;&gt;Dynamic typing as a paradigm&lt;/h2&gt;

&lt;p&gt;In this post I will start by claiming that it is not so much about static vs dynamic languages but rather about two different paradigmes or approaches to programming. Much the same way as it can be argued that Object Oriented programming is a paradigme rather than a feature of a programming language. Many of you might already be familier with Object Oriented Programming in C. That is quite popular on Linux in the &lt;a href=&#34;http://www.gtk.org&#34;&gt;Gtk toolkit&lt;/a&gt; used on the Gnome desktop. Of course C as a language was not designed for this sort of programming the way say Java or Smalltalk was designed for it.&lt;/p&gt;

&lt;p&gt;The same argument could be made about static vs dynamic typing. You could write in a dynamic style in statically typed language. I&amp;rsquo;ve done that plenty of times. GUI based programming is often a good example. Static typing isn&amp;rsquo;t very well suited for this task and thus we got things like &lt;a href=&#34;http://qt-project.org&#34;&gt;Qt&lt;/a&gt; a C++ GUI toolkit which added a preprocessor which gave dynamic featues to C++. Objective-C did much the same earlier by adding dynamic features to C.&lt;/p&gt;

&lt;h2 id=&#34;objects-as-hashtables:971ba13e9010bce2001cf2f689aed692&#34;&gt;Objects as Hashtables&lt;/h2&gt;

&lt;p&gt;So how would you program in a more dynamic fashion in a statically typed language? One way which I have used a lot myself is to use hash tables more to define your objects rather than classes. This is essentially what an object is in Python or Ruby. In C++ or Java you could store your date in a hash table and create a number of functions or methods to manipulate this hash table much the same way as you create classes with corresponding methods. But why would you do that? You lose type safety. Of course but you also gain something:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;You can easily iterate over the member of your object. Handy when applying a transformation to all members such as serializing them to disk, or duplicating them.&lt;/li&gt;
&lt;li&gt;You can add members at runtime.&lt;/li&gt;
&lt;li&gt;You can give rich meta data descriptions available at runtime for dynamic creation of e.g. GUIs.&lt;/li&gt;
&lt;li&gt;It can solve complicated problems with defining a proper taxonomy. Usually in Object Oriented programming we try to reuse code by creating an inheritance hierarchy so that we can share the implementation of methods which work in similar ways across types which are similar to each other. However a such a taxonomy might not always be easy to define. With hashtables it is easy to write a function which works on hash tables with different number of members as long as they share a common minimum of members that the function operates on.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The latter point was realized in &lt;a href=&#34;https://golang.org&#34;&gt;Go&lt;/a&gt; when they allowed satisfying interfaces implicitly. Point 3 allows creating such things as the &lt;em&gt;Predicate Editor&lt;/em&gt; found in Cocoa. One can imagine creating descriptions of each property saying what unit the property is in e.g. meters, kilo grams etc and what are legal value ranges. This can then be used to derive a GUI that allows viewing or editing corresponding objects. Visualization pipelines such as the &lt;a href=&#34;http://www.vtk.org&#34;&gt;Visualization Toolkit&lt;/a&gt; works along simular lines. You can at runtime connect algorithms sort of like Unix pipelines. To support an editor which lets humans connect different algorithms there needs to be a way to query each potential component in the pipeline and ask what sort of inputs and outputs they require. A compiler can&amp;rsquo;t check this sort of type information. First because it varies with the application domain what a type specifies and it needs to be determined at runtime for interactive usage.&lt;/p&gt;

&lt;p&gt;So a hash table with a bunch of functions is a way to simulate dynamic typing in a staticly typed languge, but thinking dynamic is more fundamental than that.&lt;/p&gt;

&lt;h2 id=&#34;pascal-vs-c:971ba13e9010bce2001cf2f689aed692&#34;&gt;Pascal vs C&lt;/h2&gt;

&lt;p&gt;To illustrate the problem with strict typing I will go all the way back to Pascal. Pascal failed and C succeeded much because of Pascal&amp;rsquo;s embrace of the static typing over practicality mentality. Brian W. Kernighan wrote an article in 1981 called &lt;a href=&#34;http://www.lysator.liu.se/c/bwk-on-pascal.html&#34;&gt;Why Pascal is Not My Favorite Programming Language&lt;/a&gt; which illustrates many of these problems. In one of his examples he says:&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;If one declares&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt; var     arr10 : array [1..10] of integer;
         arr20 : array [1..20] of integer;
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
&lt;p&gt;then arr10 and arr20 are arrays of 10 and 20 integers respectively.  Suppose we want to write a procedure &amp;lsquo;sort&amp;rsquo; to sort an integer array.  Because arr10 and arr20 have different types, it is not possible to write a single procedure that will sort them both.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This might sound laughable by todays standards, but although it is perhaps and extreme example it is really just a variation of the same problem that one will often encounter with the static typing approach. Static typing allows the compiler to catch many mistakes you do before the code runs. Making the array lenght part of its type meant you would be less likely to get out of bounds errors or pass arrays of the wrong length around. But it also made it hard to reuse code and write generic functions.&lt;/p&gt;

&lt;h2 id=&#34;3d-graphics-and-opengl:971ba13e9010bce2001cf2f689aed692&#34;&gt;3D Graphics and OpenGL&lt;/h2&gt;

&lt;p&gt;When writing graphics code it would be tempting to make everything into types in much the same manner as Pascal. One might argue that a point in 2D space should be different from a point in 3D space or even 4D space. We could write types like this (julia syntax):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Point2D
  x :: Float64
  y :: Float64
end

type Point3D
  x :: Float64
  y :: Float64
  z :: Float64
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We could then create array of 10 point objects like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;points2d = Array(Poin2D, 10)
points3d = Array(Point3D, 10)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perhaps we want to perform rotation or translation of all these points with a matrix. The problem that now arises is much the same as with Pascal. If we define a function which transforms an array of points using a matrix:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function transform(matrix :: Matrix, points :: Vector{Point2D})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then this can not be reused for an array of &lt;code&gt;Point3D&lt;/code&gt; points. Thus we get pascal style code duplication. Mathematically speaking matrix muliplication is a generic operation which we can write an algorithm for which perform the operation a matrix of any size. If we do not treat our points as types like &lt;code&gt;Point2D&lt;/code&gt; and &lt;code&gt;Point3D&lt;/code&gt; but just as arrays of numbers then we can transform an array of 10 2D points by just treating it as a matrix with 2 rows and 10 columns. &lt;code&gt;Point3D&lt;/code&gt; would be a matrix of 3 rows and 10 columns. This allows us to reuse standard fast matrix multiplication functions.&lt;/p&gt;

&lt;p&gt;OpenGL is a good example of this practice. There are no types for matricies or vectors. They are just arrays of numbers. This allows us to reuse OpenGL function for many cases.&lt;/p&gt;

&lt;h2 id=&#34;large-scale-programs:971ba13e9010bce2001cf2f689aed692&#34;&gt;Large Scale Programs&lt;/h2&gt;

&lt;p&gt;I hope that these simple examples in the small with Pascal arrays and matricies and vectors in 3D programming will allow you to get an intuition about how these problems also exist at a larger scale in most statically typed programs. When a large piece of software gets developed over many years by many different teams and pieces get bought and integrated there will be a lot of types which are similar but not quite the same, but which non the less needs to work together. We can imagine them like our 2D and 3D points. When they are separate types we will need to write a lot of conversion code to be able to reuse algorithms created for another type of object, or to be able to write some shared algorithm.&lt;/p&gt;

&lt;p&gt;With the dynamic approach this sort of problem usually disappear. That is the reason why glue languages are usually dynamic languages. Connecting different pieces of software that was not designed for each other gets quite tricky with a static language which insists on knowing everything about types at compile time. A concrete example of this is why a REPL for a statically typed language never can work as well as one for a dynamically typed one.&lt;/p&gt;

&lt;p&gt;In a dynamic language you can make structural changes at runtime. You can add or remove member variables of methods at runtime. That is fine because that does not change the type. For a statically typed language this poses a problem, since by adding or removing members you are changing the static type which all previous code was dependent on. The assumptions the compiler previously had about how to handle your types, would no longer be true and can thus not be allowed.&lt;/p&gt;

&lt;h2 id=&#34;conclusion:971ba13e9010bce2001cf2f689aed692&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Not having done any research on this I can only speculate. But my speculation is that statically typed languages mainly work for medium sized programs while dynamic typing works for the small and high level. As your program grows it can get easier to mix up your types when you only use dynamic typing. So for larger size static typing has some advantages. However as a program gets even larger one gets into the problem of having to deal with many parts that were not designed for each other. This is where the flexibility of dynamically typed languages gains ground again.&lt;/p&gt;

&lt;p&gt;So perhaps a usefull design is to have chunks of statically typed code fittet together with a dynamically typed language which orchastrates everything at a high level.&lt;/p&gt;

&lt;p&gt;[dynisstatic]: &lt;a href=&#34;https://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/&#34;&gt;https://existentialtype.wordpress.com/2011/03/19/dynamic-languages-are-static-languages/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>An introduction to Swift for Python developers</title>
      <link>http://localhost:1313/posts/swift_compared_to_python/</link>
      <pubDate>Sat, 08 Nov 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/swift_compared_to_python/</guid>
      <description>

&lt;p&gt;While Swift fundamentally isn&amp;rsquo;t very much like Python, it looks as if it has a number of similarities on the surface. For instance both have different REPL environments. These are great ways of learning how to code. I can use the Python REPL as a calculator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; 2 + 3
5
&amp;gt;&amp;gt;&amp;gt; 10 + 2 - 5
7
&amp;gt;&amp;gt;&amp;gt; 3.5 * 2
7.0
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can do much the same with Swift:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  1&amp;gt; 2 + 3
$R0: Int = 5
  2&amp;gt; 10 + 2 - 5
$R1: Int = 7
  3&amp;gt; 3.5 * 2
$R2: Double = 7
  4&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Although this is quite similar, we can already get a hint here that Swift is different and cares a lot more about type. Along with all results we can see that Swift derives the type of the result. Swift is however a lot stricter language. In Python I can write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; x = 4
&amp;gt;&amp;gt;&amp;gt; y = 5
&amp;gt;&amp;gt;&amp;gt; z = x + y
&amp;gt;&amp;gt;&amp;gt; z
9
&amp;gt;&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Despite the fact that &lt;code&gt;x&lt;/code&gt;, &lt;code&gt;y&lt;/code&gt; and &lt;code&gt;z&lt;/code&gt; does not exist already. By assigning we created them. So there is no way to avoid having the accident of thinking you are assigning to a new variable when in fact you are overwriting the value of an existing one. In Swift if we try this we get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    4&amp;gt; x = 4
error: use of unresolved identifier &#39;x&#39;
x = 4
^

    4&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead we have to write &lt;code&gt;var&lt;/code&gt; to indicate we are creating a new variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 4&amp;gt; var x = 4
x: Int = 4
  5&amp;gt; var y = 5
y: Int = 5
  6&amp;gt; var z = x + y
z: Int = 9
  7&amp;gt;    
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can assign new values to these&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    7&amp;gt; x = 30
    8&amp;gt; x
$R3: Int = 30
    9&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However if we made the variable constant by using &lt;code&gt;let&lt;/code&gt; we could not:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 12&amp;gt; let x = 4
x: Int = 4
 13&amp;gt; x = 5
error: cannot assign to &#39;let&#39; value &#39;x&#39;
x = 5
~ ^
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Swift is also a lot more strict about not mixing types. While you can do this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     13&amp;gt; 2.3 + 3
$R4: Double = 5.2999999999999998
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can&amp;rsquo;t do this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 14&amp;gt; let x = 2.3
x: Double = 2.2999999999999998
 15&amp;gt; let y = 3
y: Int = 3
 16&amp;gt; x + y
error: cannot invoke &#39;+&#39; with an argument list of type &#39;(Double, Int)&#39;
x + y
~~^~~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You will have to explicitly convert the values:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 17&amp;gt; x + Double(y)
$R6: Double = 5.2999999999999998
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;type-annotation:202d4a02dbc032c9d4c6628af62032bb&#34;&gt;Type annotation&lt;/h2&gt;

&lt;p&gt;Sometimes Swift will not be able to guess what type you wanted a variable to be. E.g. Swift could not know that &lt;code&gt;3&lt;/code&gt; was supposed to be a &lt;code&gt;Double&lt;/code&gt;. But what you can do is either write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  1&amp;gt; let y = 3.0
y: Double = 3 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or you could annotate the variable y with the type:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  2&amp;gt; let y : Double = 3
y: Double = 3 
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;arrays-and-dictionaries:202d4a02dbc032c9d4c6628af62032bb&#34;&gt;Arrays and Dictionaries&lt;/h2&gt;

&lt;p&gt;One of the nice things about Python the batteries included approach. We get usefull data types like arrays and dictionaries built into the language. So we can easily create arrays and dictionaries and manipulate them:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;gt;&amp;gt;&amp;gt; numbers = [2, 4, 6, 8]
&amp;gt;&amp;gt;&amp;gt; squared = map(lambda x: x*x, numbers)
&amp;gt;&amp;gt;&amp;gt; squared[0:3]
[4, 16, 36] 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Swift follows a similar philosophy and allows you to create collections of objects with succint syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  4&amp;gt; let numbers = [2, 4, 6, 8] 
numbers: [Int] = 4 values {
  [0] = 2
  [1] = 4
  [2] = 6
  [3] = 8
}
  5&amp;gt; let squared = map(numbers, {x in x*x}) 
squared: [Int] = 4 values {
  [0] = 4
  [1] = 16
  [2] = 36
  [3] = 64
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see this is very similar. But Swift has a number of alternative ways to do this with ruby inspired syntax sugar:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  8&amp;gt; let squared = map(numbers) {x in x*x}
squared: [Int] = 4 values {
  [0] = 4
  [1] = 16
  [2] = 36
  [3] = 64
}
  9&amp;gt; let squared = numbers.map {x in x*x} 
squared: [Int] = 4 values {
  [0] = 4
  [1] = 16
  [2] = 36
  [3] = 64
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To slice arrays we can either do that with a closed &lt;code&gt;...&lt;/code&gt; or open interval &lt;code&gt;..&amp;lt;&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  6&amp;gt; squared[0...3]
$R0: Slice&amp;lt;Int&amp;gt; = 4 values {
  [0] = 4
  [1] = 16
  [2] = 36
  [3] = 64
}
  7&amp;gt; squared[0..&amp;lt;3]
$R1: Slice&amp;lt;Int&amp;gt; = 3 values {
  [0] = 4
  [1] = 16
  [2] = 36
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;functions:202d4a02dbc032c9d4c6628af62032bb&#34;&gt;Functions&lt;/h2&gt;

&lt;p&gt;With python you can easily create a function like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;def add(a, b):
    return a + b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However that is not going to work in Swift:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 21&amp;gt; func add(a, b) { 
 22.     return a + b 
 23. }    
error: use of undeclared type &#39;a&#39;
func add(a, b) {
         ^
error: use of undeclared type &#39;b&#39;
func add(a, b) {
            ^
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because Swift needs to know what the type of your variables are. Unlike like our previous example where we assigned a value right away, there is no way for Swift to know what the type of &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; is going to be. It can&amp;rsquo;t infer it, so we have annotate the variables:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func add(a: Int, b: Int) -&amp;gt; Int {
    return a + b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But this has some limitations compared to the Python example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 4&amp;gt; add(2, 3)
$R0: Int = 5
  5&amp;gt; add(2.0, 3.3)
error: cannot convert the expression&#39;s type &#39;(FloatLiteralConvertible, FloatLiteralConvertible)&#39; to type &#39;Int&#39;
add(2.0, 3.3)
^~~~~~~~~~~~~
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;generics:202d4a02dbc032c9d4c6628af62032bb&#34;&gt;Generics&lt;/h2&gt;

&lt;p&gt;Python allowed us to use any type of number, but now we have limited ourselves to integers. We can&amp;rsquo;t e.g. use float values. The Swift solution for this is Generics as found in C#, Java and many other languages. If this had been C++ I could have written something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func add&amp;lt;T&amp;gt;(a: T, b: T) -&amp;gt; T {
    return a + b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To indicate that &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt; can be of any type but they have to be of the same type &lt;code&gt;T&lt;/code&gt;. Likewise with the result. However this would give us the error:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;error: cannot invoke &#39;+&#39; with an argument list of type &#39;(T, T)&#39;
return a + b
       ~~^~~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reason being that an arbitrary type &lt;code&gt;T&lt;/code&gt; doesn&amp;rsquo;t support adding. C++ solves this problem by checking every use of &lt;code&gt;add()&lt;/code&gt; in the program and making sure only types which support &lt;code&gt;+&lt;/code&gt; is provided as arguments. But that is actually a terrible solution as it produces errors inside the function at the offending line. Thus users of a third party library has to understand how a third party function is implemented. So the Swift way of doing this is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func add&amp;lt;T: Addable&amp;gt;(a: T, b: T) -&amp;gt; T {
    return a + b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To indicate that that the type &lt;code&gt;T&lt;/code&gt; has to implement the protocol &lt;code&gt;Addable&lt;/code&gt;. A protocol is like a C# or Java interface. It lists functions which any class which wants to adhere to the protocol has to implement. In this case we say that &lt;code&gt;T&lt;/code&gt; has to be of a type that support the &lt;code&gt;+&lt;/code&gt; operator. Unfortunatly no &lt;code&gt;Addable&lt;/code&gt; protocol exists in Swift. In fact Swift is at the moment quite lacking in protocols. The whole Swift standard library is quite tiny at the momment. So the above code will give the error:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    error: use of undeclared type &#39;Addable&#39;
func add&amp;lt;T: Addable&amp;gt;(a: T, b: T) -&amp;gt; T {
            ^~~~~~~ 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Thus we have to specify the &lt;code&gt;Addable&lt;/code&gt; protocol ourselves:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol Addable {
    func +(a: Self, b: Self) -&amp;gt; Self
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The use of &lt;code&gt;Self&lt;/code&gt; looks strange. Self is a sort of placeholder for the type of the object the method is being invoked on. So e.g. when &lt;code&gt;+&lt;/code&gt; is being invoked on an &lt;code&gt;Int&lt;/code&gt; object then &lt;code&gt;Self&lt;/code&gt; is the same as &lt;code&gt;Int&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Now we have the protocol but that only takes us half way. No concrete type is actually implementing this protocol. If this was Java or C++ that would be the end of this, because we would have had to implement our own number types somehow. Existing types can&amp;rsquo;t implement a new interface. Except in Swift you can. We can add methods to existing types or have existing types implement new protocols through extensions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension Int: Addable {}
extension Double: Addable {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This specifies that &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;Double&lt;/code&gt; implements &lt;code&gt;Addable&lt;/code&gt;. Notice we don&amp;rsquo;t have to actually implement any methods ourselves because &lt;code&gt;Int&lt;/code&gt; and &lt;code&gt;Double&lt;/code&gt; already have the &lt;code&gt;+&lt;/code&gt; method/operator. Now we can write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  1&amp;gt; add(1, 2)
$R0: (Int) = 4
  2&amp;gt; add(2.0, 3.0)
$R1: (Double) = 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However if we use a &lt;code&gt;Float&lt;/code&gt; we get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  3&amp;gt; let x : Float = 2
x: Float = 2
  4&amp;gt; let y : Float = 3
y: Float = 3 
  5&amp;gt; add(x, y)
error: Type &#39;Float&#39; does not conform to protocol &#39;Addable&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We get an error because we have not specified that &lt;code&gt;Float&lt;/code&gt; implements our &lt;code&gt;Addable&lt;/code&gt; protocol.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Comparison of the Go tour with Swift</title>
      <link>http://localhost:1313/posts/a_comparison_of_go_and_swift/</link>
      <pubDate>Tue, 15 Jul 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/a_comparison_of_go_and_swift/</guid>
      <description>

&lt;p&gt;One of my favorite programming languages is Go, so I thought it might be fun to do a bit of a superficial comparison of it with Swift which I am hoping will be a new favorite given that I work professionally as an iOS developer. Go takes such a bare bones and simple approach to programming that one can quite quickly get a sense of what it is like using it. It will take longer time to make up an opinion about Swift.&lt;/p&gt;

&lt;h3 id=&#34;hello-world:9abb9ee4300cdd8e97474ebf0d072fc6&#34;&gt;Hello world&lt;/h3&gt;

&lt;p&gt;The Go tour starts with the infamous &amp;ldquo;Hello world&amp;rdquo; program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import &amp;quot;fmt&amp;quot;

func main() {
    fmt.Println(&amp;quot;Hello, 世界&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see below Swift looks very similar at first glance. Although &lt;code&gt;main&lt;/code&gt; doesn&amp;rsquo;t have any special meaning. It is just a function.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Foundation

func main() {
    println(&amp;quot;Hello, 世界&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So we should rather replace the code with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Foundation

println(&amp;quot;Hello, 世界&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;import:9abb9ee4300cdd8e97474ebf0d072fc6&#34;&gt;Import&lt;/h3&gt;

&lt;p&gt;In Go one divides the code into lots of small packages, which you can import as shown in the tour example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main

import (
    &amp;quot;fmt&amp;quot;
    &amp;quot;math/rand&amp;quot;
)

func main() {
    fmt.Println(&amp;quot;My favorite number is&amp;quot;, rand.Intn(10))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With Swift we typically import large frameworks containg a number of libraries. For just simple math libraries &lt;code&gt;Foundation&lt;/code&gt; or &lt;code&gt;Cocoa&lt;/code&gt; isn&amp;rsquo;t needed. You can import e.g. the &lt;code&gt;Darwin&lt;/code&gt; framework.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;import Darwin

let favorite = rand() % 10
println(&amp;quot;My favorite number is&amp;quot;, favorite)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;functions:9abb9ee4300cdd8e97474ebf0d072fc6&#34;&gt;Functions&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;func add(x int, y int) int {
    return x + y
}

func main() {
    fmt.Println(add(42, 13))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Swift is similar placing type info last instead of traditional C/C++ way of putting type first.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func add(x: Int, y: Int) -&amp;gt; Int {
    return x + y
}


println(add(42, 13))
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;multiple-results:9abb9ee4300cdd8e97474ebf0d072fc6&#34;&gt;Multiple results&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;func swap(x, y string) (string, string) {
    return y, x
}

func main() {
    a, b := swap(&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;)
    fmt.Println(a, b)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Swift doesn&amp;rsquo;t really return multiple values like Go functions but instead returns tuples which lets you accomplish basically the same thing.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func swap(x: String, y: String) -&amp;gt; (String, String) {
    return (y, x)
}

var (a, b) = swap(&amp;quot;hello&amp;quot;, &amp;quot;world&amp;quot;)
println(&amp;quot;\(a) \(b)&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another minor difference is that Swift can do &lt;code&gt;println(a)&lt;/code&gt; but not &lt;code&gt;println(a, b)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;named-results:9abb9ee4300cdd8e97474ebf0d072fc6&#34;&gt;Named results&lt;/h3&gt;

&lt;p&gt;You can name the results in both Go and Swift but the meaning is very different, because Go has multiple return variables and Swift has tuples instead. In the Go example &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; can be assigned to directly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func split(sum int) (x, y int) {
    x = sum * 4 / 9
    y = sum - x
    return
}

func main() {
    fmt.Println(split(17))
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can&amp;rsquo;t do that in Swift, because naming here has a different meaning. What you are doing is naming the entries in the tupple so, that you can refer to the entries later. It is sort of like making a struct on the fly.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func split(sum: Int) -&amp;gt; (x: Int, y: Int) {
    var x = sum * 4 / 9
    var y = sum - x
    return (x, y)
}

var result = split(17)

println(result.x)
println(result.y)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;variables:9abb9ee4300cdd8e97474ebf0d072fc6&#34;&gt;Variables&lt;/h3&gt;

&lt;p&gt;In Go &lt;code&gt;var&lt;/code&gt; start the definition of one or more variables with the type last.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var i int
var c, python, java bool

func main() {
    fmt.Println(i, c, python, java)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Swift is similar, except in Swift variables are never automatically initialized to 0 or false like in Go. If a variable is not initialized it is undefined and you are not allowed to use it. So you  must assign to it before you can read from it. Also multiple assignment relies on the tuple concept.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var i: Int
var c, python, java: Bool
var (c, python, java) = (false, false, false)

println(&amp;quot;\(c) \(python) \(java)&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So when doing initialization Go and Swift look more similar:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var i, j int = 1, 2
var c, python, java = true, false, &amp;quot;no!&amp;quot;

func main() {
    fmt.Println(i, j, c, python, java)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the difference that type annotations work a bit different. If you want every variable in the tupple to be of type &lt;code&gt;Int&lt;/code&gt; you have to specify that for each individual variable.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var (i: Int, j: Int)  = (1, 2)
var (c, python, java) = (true, false, &amp;quot;no!&amp;quot;)

println(&amp;quot;\(i) \(j) \(c) \(python) \(java)&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The tradeoff here is that that allows you to chose which variables you want infered and which ones you want to specify. So with Swift you could write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var (i: Float, j)  = (1, 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which would turn &lt;code&gt;i&lt;/code&gt; into a floating point number while &lt;code&gt;j&lt;/code&gt; would be infered to be an integer. Writing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var i Float64, j  = 1, 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in Go would be a compiler error. Type has to come last and apply to all variables.&lt;/p&gt;

&lt;h3 id=&#34;shorthand:9abb9ee4300cdd8e97474ebf0d072fc6&#34;&gt;Shorthand&lt;/h3&gt;

&lt;p&gt;In Go there is a shorthand notation using &lt;code&gt;:=&lt;/code&gt; when infering variables so you could write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;k := 3
c, python, java := true, false, &amp;quot;no!&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There isn&amp;rsquo;t anything similar in Swift.&lt;/p&gt;

&lt;h3 id=&#34;type-conversions:9abb9ee4300cdd8e97474ebf0d072fc6&#34;&gt;Type conversions&lt;/h3&gt;

&lt;p&gt;Both Swift and Go are much more strict on type conversions than what is traditional for C/C++. Conversion from &lt;code&gt;int&lt;/code&gt; to &lt;code&gt;float&lt;/code&gt; won&amp;rsquo;t happen automatically.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var x, y int = 3, 4
var f float64 = math.Sqrt(float64(x*x + y*y))
var z int = int(f)
fmt.Println(x, y, z)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Swift works similar:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var (x : Int, y : Int) = (3, 4)
var f : Float = sqrt(Float(x*x + y*y))
var z : Int = Int(f)
println(&amp;quot;\(x) \(y) \(z)&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both Swift and Go can treat primitive types as first class citizens. You can create a type from a e.g. an &lt;code&gt;int&lt;/code&gt; in Go and add method to it. Swift is slightly different in this regard in that the most primitive types are not exposed directly. &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;Float&lt;/code&gt; etc are really structs which may contain methods. Conversion from say &lt;code&gt;Float&lt;/code&gt; to &lt;code&gt;Int&lt;/code&gt; isn&amp;rsquo;t built into the language but rather exploits one of the initializer methods on the &lt;code&gt;Int&lt;/code&gt; type that takes a &lt;code&gt;Float&lt;/code&gt; as an argument.&lt;/p&gt;

&lt;p&gt;The example above could also be simplified. We don&amp;rsquo;t need to write types as often. Here is an example from a Swift REPL session, demonstrating this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ swift
Welcome to Swift!  Type :help for assistance.
  1&amp;gt; var (x, y) = (3, 4)
x: Int = 3
y: Int = 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see the REPL will inform us that it infered the &lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt; to be of type &lt;code&gt;Int&lt;/code&gt;. Regular math functions such as &lt;code&gt;sqrt&lt;/code&gt; is in the &lt;em&gt;Darwin&lt;/em&gt; package.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  2&amp;gt; import Darwin
  3&amp;gt; var f = sqrt(Float(x*x + y*y)) 
f: (Float) = 5
  4&amp;gt; var z = Int(f)
z: Int = 5
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Swift infers that the result of &lt;code&gt;sqrt&lt;/code&gt; has to be of type &lt;code&gt;Float&lt;/code&gt; if the input is of type &lt;code&gt;Float&lt;/code&gt;. You can&amp;rsquo;t quite do the same in Go since Go does not overload functions on types.&lt;/p&gt;

&lt;h3 id=&#34;structs:9abb9ee4300cdd8e97474ebf0d072fc6&#34;&gt;Structs&lt;/h3&gt;

&lt;p&gt;Both Go and Swift support structs. There meaning is quite different however, since Swift is more like C# in that it has the notion of both structs and classes to deal with the lack of pointers. In Go it is idiomatic to access variables directly without accessors.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Vertex struct {
    X int
    Y int
}

func main() {
    v := Vertex{1, 2}
    v.X = 4
    fmt.Println(v.X)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Swift we can&amp;rsquo;t access member variables directly. Although the code looks almost identical Swift always creates accessors conceptually. In machine code it might of course perform a direct access.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Vertex {
  var x : Int
  var y : Int
}

var v = Vertex(x: 1, y: 2)
v.x = 4
println(v.x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Swift initializers we also have to give the names of the arguments. With Go this is optional. The Go code could have been written like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;v := Vertex{X: 1, Y: 2}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A significant conceptual difference is that in Swift creating any object requires running an initializer function. In the Go example the data structure is just initialized directly. No function call is done. If you want an initialiser function for &lt;code&gt;Vertex&lt;/code&gt; objects in Go you have to write a free function explicity:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func NewVertex(x, y int) Vertex {
  return Vertex{x, y}
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;swift-inout-and-go-pointers:9abb9ee4300cdd8e97474ebf0d072fc6&#34;&gt;Swift inout and Go pointers&lt;/h3&gt;

&lt;p&gt;Go has real pointers, but Swift allows you to things which makes it look as if it has pointers. Take this example of pointer usage in Go:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func swapXY(v *Vertex) {
    tmp := v.X
    v.X = v.Y
    v.Y = tmp
}

v := Vertex{1, 2}
swapXY(&amp;amp;v) // v becomes Vertex{2, 1}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can do almost exactly the same in Swift:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func swapXY(inout v: Vertex) {
   var tmp = v.x 
   v.x = v.y 
   v.y = tmp 
} 

var v = Vertex(x: 1, y: 2)
swapXY(&amp;amp;v)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However except for when using unsafe features you can&amp;rsquo;t represent an inout function argument as a separate variable in Swift code the ampersand, only makes sense in the context of calling a function. So this will NOT work in Swift:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var p = &amp;amp;v // error: type &#39;inout Vertex&#39; of variable is not materializable
swapXY(p)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However Go has real pointers which allows you to write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;p := &amp;amp;v
swapXY(p)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Go pointers can be passed around and stored like any other variable. This also displays so key design differences between Swift and Go. Swift is generally designed to make code safe and prevent you from accidentally doing something dangerous or wrong. Because you have to prefix with ampersand at the call site it will always be clear to the code reader when you are potentially modifying a struct. Go instead opts for simplicity by having one simple feature which has many use cases.&lt;/p&gt;

&lt;h3 id=&#34;classes:9abb9ee4300cdd8e97474ebf0d072fc6&#34;&gt;Classes&lt;/h3&gt;

&lt;p&gt;This naturally brings us to classes. Classes is the way Swift allows us to simulate some of the properties of pointers in Go. If we defined &lt;code&gt;Vertex&lt;/code&gt; as a class instead of a struct we could perform the &lt;code&gt;swapXY&lt;/code&gt; without using &lt;code&gt;inout&lt;/code&gt; because variables of class types are always pointers.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;class Vertex {
  var x : Int
  var y : Int

  // classes don&#39;t have initializers automatically made
  init(x: Int, y: Int) {
    self.x = x
    self.y = y
  }
}

// this works because v is now essentially a pointer
func swapXY(v: Vertex) {
   var tmp = v.x 
   v.x = v.y 
   v.y = tmp 
}

var v = Vertex(x: 1, y: 2)
swapXY(v) // Becomes Vertex(2, 1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So Swift structs allow us to use variables as values. Meaning they get copied with every assignment (except when using &lt;code&gt;inout&lt;/code&gt; arguments) while classes let use variables as pointers (assignment does not cause a copy). With Go we can manage with just &lt;code&gt;struct&lt;/code&gt; because we can make pointers to values using the ampersand operator.&lt;/p&gt;

&lt;p&gt;Other than that Swift classes works much the same as classes in other languages. It is what allows us to support implementation inheritance. Go does not support implementation inheritance. Go is not alone in this regard new languages like Clojure and Rust also tries to avoid inheritance. For Swift that was not an option as one of the important design goals was to be able to smoothly interface with Objective-C and existing Cocoa libraries which use inheritance hierarchies heavily.&lt;/p&gt;

&lt;p&gt;Both Swift and Go allows you to specify methods on structs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Vertex struct {
    X, Y float64
}

func (v Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
    v := Vertex{3, 4}
    fmt.Println(v.Abs())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Go the methods are placed outside the struct, while in Swift they must be inside. To Go approach makes it easy to split method definitions over several files. You can achieve the same in Swift using class extensions.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Vertex {
  var x : Float
  var y : Float

  func abs() -&amp;gt; Float {
    return sqrt(x*x + y*y)
  }
}

var v = Vertex(x:3, y:4)
println(v.abs())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However in Swift it would be more idiomatic to treat the length of a vertex as a calculated property. To do that the code becomes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Vertex {
  var x : Float
  var y : Float

  var abs : Float {
    return sqrt(x*x + y*y)
  }
}

var v = Vertex(x:3, y:4)
println(v.abs) // Looks like member variable access
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;swift-protocols-and-go-interfaces:9abb9ee4300cdd8e97474ebf0d072fc6&#34;&gt;Swift Protocols and Go Interfaces&lt;/h3&gt;

&lt;p&gt;Lack of classes does of course not mean that Go doesn&amp;rsquo;t support polymorphism. It does that using &lt;em&gt;interfaces&lt;/em&gt; which are quite similar to Swift &lt;em&gt;protocols&lt;/em&gt;. We don&amp;rsquo;t have to explicitly define that a struct implements an interface in Go, so if we define a interface like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;type Abser interface {
    Abs() float64
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can automatically use &lt;code&gt;Vertex&lt;/code&gt; with it since it has a &lt;code&gt;Abs()&lt;/code&gt; method even if &lt;code&gt;Vertex&lt;/code&gt; came from a third party library we didn&amp;rsquo;t own and couldn&amp;rsquo;t modify.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func main() {
    var a Abser
    v := Vertex{3, 4}
    a = v

    fmt.Println(a.Abs()) // displays 5
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Even though Swift does not allow classes or struct to implicitly implement a protocol like Go, it does still allow us to make third party classes and struct implement protocols they were never designed for. If we write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;protocol Abser { 
  var abs : Float { get }
}

var v : Abser = Vertex(x:3, y:4)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We will get the error&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;type &amp;lsquo;Vertex&amp;rsquo; does not conform to protocol &amp;lsquo;Abser&amp;rsquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;So we can&amp;rsquo;t do like Go, but we can tell Swift that &lt;code&gt;Vertex&lt;/code&gt; implements &lt;code&gt;Abser&lt;/code&gt; using a class extension (or perhaps we should call it struct extension in this case). Here is an excerpt from a Swift REPL session demonstrating that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 13&amp;gt; extension Vertex : Abser { 
 14. }    
 15&amp;gt; var v : Abser = Vertex(x:3, y:4) 
v: Vertex = {
  x = 3
  y = 4
}
 16&amp;gt; v.abs
$R0: Float = 5
 17&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If our &lt;code&gt;Vertex&lt;/code&gt; class had not already implemented &lt;code&gt;abs&lt;/code&gt; we could have added it with the class extension:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;extension Vertex : Abser {
    var abs : Float {
      return sqrt(x*x + y*y)
    }    
}    
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;conclusion:9abb9ee4300cdd8e97474ebf0d072fc6&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;Go and Swift have a number of superficial similarities. So you can write code that looks almost identical and does the same thing but the way it works under the hood might be radically different. E.g. using pointers in Go and inout variables in Swift often looks almost identical but works very different.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Swift is Kotlin</title>
      <link>http://localhost:1313/posts/swift-is-kotlin/</link>
      <pubDate>Thu, 05 Jun 2014 00:00:00 +0000</pubDate>
      
      <guid>http://localhost:1313/posts/swift-is-kotlin/</guid>
      <description>

&lt;p&gt;Around the internet people are saying Apple&amp;rsquo;s &lt;a href=&#34;https://developer.apple.com/swift/&#34;&gt;Swift&lt;/a&gt; looks like C#, JavaScript etc. This of course is just in the most superficial manner. E.g. both JavaScript and &lt;a href=&#34;https://developer.apple.com/swift/&#34;&gt;Swift&lt;/a&gt; has the &lt;code&gt;var&lt;/code&gt; keyword. But it means completely different things since &lt;a href=&#34;https://developer.apple.com/swift/&#34;&gt;Swift&lt;/a&gt; is statically typed and JavaScript is not.&lt;/p&gt;

&lt;p&gt;Anyway being generally curious about programming languages I could see similarities in &lt;a href=&#34;https://developer.apple.com/swift/&#34;&gt;Swift&lt;/a&gt; with &lt;a href=&#34;http://www.rust-lang.org&#34;&gt;Rust&lt;/a&gt;, &lt;a href=&#34;http://golang.org&#34;&gt;Go&lt;/a&gt;, Scala and Ruby. However all these languages differ from Swift in quite a number of ways.&lt;/p&gt;

&lt;p&gt;But if you actually really want find a language that is close to &lt;a href=&#34;https://developer.apple.com/swift/&#34;&gt;Swift&lt;/a&gt;, I don&amp;rsquo;t know of anything closer than &lt;a href=&#34;http://kotlin.jetbrains.org&#34;&gt;Kotlin&lt;/a&gt; developed by JetBrains. They both seem to have many of the same goals:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Both want to integrate very well with their respective platform. Kotlin with Java and Swift with Objective-C. Unlike Scala which seems more focused on the idea of briding OO and functional programming.&lt;/li&gt;
&lt;li&gt;IDE support seems important. JetBrains want a language that works well with their IDE. Apple wants something that works well with xCode. Great tools is created in lockstep like e.g. Swift Playground. Rust and Scala e.g. are not heavily tool focused.&lt;/li&gt;
&lt;li&gt;Simplicity and familiarity are important goals. There are more sofisticated languages out there than &lt;a href=&#34;http://kotlin.jetbrains.org&#34;&gt;Kotlin&lt;/a&gt; and &lt;a href=&#34;https://developer.apple.com/swift/&#34;&gt;Swift&lt;/a&gt; such as Scala, Rust and Haskell. But learning these languages fully requires a lot more effort.&lt;/li&gt;
&lt;li&gt;Functional programming is used as a way to enhance the language were it makes sense but it isn&amp;rsquo;t any central goal like in e.g. Clojure and Scala.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;feature-and-syntax-similarities:3258c3e2e0b96cdabd99ff90bdbd02cd&#34;&gt;Feature and Syntax similarities&lt;/h2&gt;

&lt;p&gt;Both place type information after the name of the identifier unlike C/C++, C# and Java. This is also similar to Go, Rust, Pascal etc. Kotlin:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;fun sum(a : Int, b : Int) : Int { 
  return a + b 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Swift:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;func sum(a : Int, b : Int) -&amp;gt; Int { 
  return a + b 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Syntax for ranges and for loops is similar:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for (index in 1...5) {
    println(&amp;quot;$(index) times 5 is $(index * 5)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Swift:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for index in 1...5 {
    println(&amp;quot;\(index) times 5 is \(index * 5)&amp;quot;)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;pattern-matching:3258c3e2e0b96cdabd99ff90bdbd02cd&#34;&gt;Pattern matching&lt;/h3&gt;

&lt;p&gt;Both do pattern matching in a smiliar manner, although different keywords is used. In Kotlin you write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;when (count) {
in 0 -&amp;gt;
    naturalCount = &amp;quot;no&amp;quot;
in 1...3 -&amp;gt;
    naturalCount = &amp;quot;a few&amp;quot;
in 4...9 -&amp;gt;
    naturalCount = &amp;quot;several&amp;quot;
in 10...99 -&amp;gt;
    naturalCount = &amp;quot;tens of&amp;quot;
in 100...999 -&amp;gt;
    naturalCount = &amp;quot;hundreds of&amp;quot;
in 1000...999_999 -&amp;gt;
    naturalCount = &amp;quot;thousands of&amp;quot;
else -&amp;gt;
    naturalCount = &amp;quot;millions and millions of&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note this is slightly wrong since I don&amp;rsquo;t believe Kotlin support &lt;code&gt;...&lt;/code&gt;. Just &lt;code&gt;..&lt;/code&gt;. But it isn&amp;rsquo;t that important with respect to showing the similarities and different between the pattern matching syntax.
Which in Swift turns into:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;when (count) {
c 0:
    naturalCount = &amp;quot;no&amp;quot;
case 1...3:
    naturalCount = &amp;quot;a few&amp;quot;
case 4...9:
    naturalCount = &amp;quot;several&amp;quot;
case 10...99:
    naturalCount = &amp;quot;tens of&amp;quot;
case 100...999:
    naturalCount = &amp;quot;hundreds of&amp;quot;
case 1000...999_999:
    naturalCount = &amp;quot;thousands of&amp;quot;
default:
    naturalCount = &amp;quot;millions and millions of&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;type-casting:3258c3e2e0b96cdabd99ff90bdbd02cd&#34;&gt;Type casting&lt;/h3&gt;

&lt;p&gt;Even type casting looks and behaves in the same way, and the both have Option types to avoid null pointer exceptions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val x : String = y as String   // unsafe case. May throw exception.
val x : String? = y as? String // safe cast. Nil if not working
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Swift:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;let x : String = y as String
let x : String? = y as? String
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;enum-types:3258c3e2e0b96cdabd99ff90bdbd02cd&#34;&gt;Enum types&lt;/h3&gt;

&lt;p&gt;Enumerations are quite different. They have some overlapping functionality. Both allow you to do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum class Direction { 
  NORTH 
  SOUTH 
  WEST 
  EAST 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Swift:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum  Direction { 
  case NORTH, SOUTH, WEST, EAST 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But for more advance case Kotlin and Swift enums look quite different. I don&amp;rsquo;t understand either of them well enough to reason whether they actually represent the same thing deep down or if they are fundamentally different although I lean towards the latter. In Kotlin you can write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum class Color(val rgb : Int) { 
  RED : Color(0xFF0000) 
  GREEN : Color(0x00FF00) 
  BLUE : Color(0x0000FF) 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Swift my impression is that enums are not really objects in the normal sense. I believe technically they are called a sum type, which is also called a variant in some languages. You can reproduce the Kotlin example in a bit clunky way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;struct Color {
    var red : Int
    var green : Int
    var blue : Int
}

enum ColorEnum {
    case RED, GREEN, BLUE
    var value : Color {
        switch self {
        case .RED:
             return Color(red: 1, green: 0, blue: 0)
        case .BLUE:
            return Color(red: 0, green: 0, blue: 1)
        case .GREEN:
            return Color(red: 0, green: 1, blue: 0)
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But I believe the more appropriate Swift way of doing it is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum  Color { 
  RED  (0xFF, 0x00, 0x00) 
  GREEN(0x00, 0xFF, 0x00) 
  BLUE (0x00, 0x00, 0xFF) 
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which works better for pattern matching in &lt;code&gt;switch-case&lt;/code&gt; statements. The advantage of the Swift approach is that it allows us to define variants:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;enum ServerResponse {
  case Result(String, String)
  case Error(String)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So you can easily define results from functions which are either a value or error object but which the user is forced to extract with pattern matching using &lt;code&gt;switch&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;switch fetchSunriseAndSunsetTimes() {
case let .Result(sunrise, sunset):
    let serverResponse = &amp;quot;Sunrise is at \(sunrise) and sunset is at \(sunset).&amp;quot;
case let .Error(error):
    let serverResponse = &amp;quot;Failure...  \(error)&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h1 id=&#34;conclusion:3258c3e2e0b96cdabd99ff90bdbd02cd&#34;&gt;Conclusion&lt;/h1&gt;

&lt;p&gt;I am not going to go through every feature, but it is clear when you look at how the languages work that there are a lot of similarities. In the regard that they are different I believe that is born out of the limitations set by each respective platform JVM or Objective-C runtime. Swift likely chose a more sofisticated enum type system with sum types to deal with the fact that exceptions can not easily be provided in a non GC language with Cocoa not being exception safe. I know there isn&amp;rsquo;t an obvious connection here but I believe enum types will be used for building an error handling system in the future for Apple API&amp;rsquo;s. Kotlin is more traditional in supporting exceptions which already works quite well on the JVM.&lt;/p&gt;

&lt;p&gt;Swift also needed away to deal with the peculiar naming of method in iOS where each argument has a name. Cocoa programming is also frequently uses plain C structs for things such as points, rectangles etc. Thus this is explicitly supported in Swift as value types. Java has had no support for this traditionally and thus it is probably harder to get value types to interact with Java API&amp;rsquo;s. Hence Kotlin has omitted value types.&lt;/p&gt;

&lt;p&gt;One advantage I can see from an iOS developers point of view is that I ocassionally work on Android development and if Kotlin is well supported on Android then it will make switching between iOS and Android development a smaller overhead languagewise. iOS and Android APIs are of course quite different but it might be possible to write model objects which are quite similar. Perhaps one can create tools which translate between Swift and Kotlin code as long as one stay with a common subset of functionality. The main problem with writing library code which could be shared is that a Swift API will not use exceptions for error handling but likely enum types. Kotlin APIs will likely rely on exceptions. So it is not possible to write shared functionality without sacrificing benefits on one of the platforms.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>